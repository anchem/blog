---
title: 基于线程的并发编程——概览
date: 2020-03-23 23:54:40
categories: 软件工程师系列
tags:
- C语言
- 并发编程
- Pthreads
keywords: C语言,并发编程,Pthreads
description: 本篇介绍了C语言中基于Pthreads的多线程并发编程。
---

# 1. 背景知识

在类UNIX系统的世界里，要说基于线程的并发编程，那就要请出**POSIX Threads**了。为了说明它的使用，我们以C语言为工具，来了解一下吧。（本文假设你已经了解进程、线程和并发编程的基本概念了）

# 2. POSIX Threads

## 2.1. 概念

要说POSIX Threads，得先说说POSIX是什么。**POSIX（Portable Operating System Interface）**也叫可移植操作系统接口，是最初由IEEE定义的一套标准族，它定义了操作系统应该提供的各种服务。因为早期UNIX系统有各种各样的版本，不同版本之间的系统接口各不相同（包括软件和硬件），一个软件可能在这个操作系统上运行着好好的，到了另一个系统上就挂掉了。而它出现的目的就是为了提升应用程序在各种UNIX系统环境之间的可移植性，说白了就是达到软件一次编写，哪儿都能跑的目的。

**POSIX Threads**，就是基于POSIX的线程标准，它定义了一套管理和操纵线程的API，也就是接口。实现了这个标准的库常常被称为**Pthreads**。因为POSIX标准是基于UNIX的，所以Pthreads一般只能用于类UNIX的系统，当然Windows上的实现也存在，但本次先不讨论它。

## 2.2. Why & When

一般简单的程序可能用不到多线程，但现在大部分的程序基本都是多线程的，因为多线程能够带来更好的性能和响应速度。比如浏览器，大部分人在使用浏览器的时候往往会打开多个窗口，并且在浏览当前网页的同时，其他页面也能同时加载。如果这样的浏览器只有一个线程的话，它是无法提供上述功能的，只有多线程的浏览器才可以。比如一个线程负责展示你当前浏览的页面，另一个线程负责加载你刚才打开的另一个页面。

而对于使用Pthreads的多线程程序来说，好处包括以下几个方面：

- **轻量级**
 - 相对于进程来说，线程的创建和管理会消耗更少的系统资源。
- **高效的数据交换**
 - 由于线程共享同一进程内的地址空间，线程间的数据通讯不会带来额外的拷贝动作。
 - 线程间的通讯常常是CPU和缓存或内存间的数据交换，比MPI提供的共享内存的交换方式要高效的多。
- **高性能**
 - 如果程序内有等待I/O的动作，它不会因此而阻塞，多线程的能力允许不同的任务并发执行。
 - 任务可以按照优先级顺序执行，高优先级可以推迟或打断低优先级的任务。
 - 具备异步事件处理的能力，当前正在处理的事件和新到来的事件可以交错执行。

如果你的程序需要具备以上的能力的话，那么请放心大胆地使用Pthreads吧。
 
## 2.3. API概述

Pthreads由一个pthreads.h文件和一个线程库组成，定义了一套C语言的数据类型、函数和常量。库里所有的标识符都以**pthread_**打头，比较好辨认，在后面的详细介绍里我们会看到。
Pthreads库主要使用以下几种数据类型：

- **pthread_t**：线程句柄。
- **pthread_attr_t**：线程属性。
- **pthread_mutex_t**：互斥量数据类型。
- **pthread_cond_t**：条件变量数据类型。
- **pthread_barrier_t**：同步屏障数据类型。

这些函数可以分成四大类，分别是：

- **线程管理**。例如创建、销毁、结合、分离线程，设置和查询线程属性等方法。
- **互斥锁**。创建、销毁、锁定、解锁、设置属性等方法。
- **条件变量**。创建、摧毁、等待、通知、设置与查询条件变量属性等操作。
- **同步管理**。管理读写锁和屏障。

## 2.4. 引入

要在程序中引入Pthreads很简单，只需要做2件事：

1. 源代码引入Pthreads的头文件`#include <pthread.h>`
2. 编译时添加编译命令`gcc -pthread`或`g++ -pthread`

## 2.5. 分类介绍

### 2.5.1. 线程管理

线程管理类的API提供了**创建**、**销毁**、**取消**、**结合**、**分离**线程与设置和查询线程**属性**等方法。

详细介绍请看：[《基于线程的并发编程——线程管理》][1]（待补充）

### 2.5.2. 线程同步

当多个线程之间不会共享相同的内存，也就是说每个线程使用的变量都是其他线程不会读取和修改的，那么大家就相安无事，不会存在什么问题。就像我从我家的冰箱里拿一个鸡蛋，和你从你家的冰箱里拿一个，咱俩用的是各自独立的冰箱，相互之间没有什么影响。但是，如果咱俩住在一个屋檐下，共用一个冰箱，想要同时从冰箱里拿东西，就会存在竞争问题了。多线程之间的同步也是类似的道理。

线程对内存的使用无非就是**读**和**写**，在多个线程使用共享的内存时，如果大家都只是读取，而不会修改这块内存的值，那么也没问题。但一旦有一个或多个线程可能会修改这块内存的值，那么就会遇到**一致性**的问题。比如当一个线程在修改一个变量，那么其他线程在读取这个变量的时候可能会看到一个不一致的值。为什么会出现这种情况呢？

**【原因】**

在高级编程语言的代码里，一个变量的修改只需要一条语句就足够了，但它的实际执行则需要多条机器指令来完成，如下例：

```
// main.c
#include <stdio.h>
#include <pthread.h>
int num = 0;

void *ThreadFunc(void *any)
{
    num++; // 修改全局变量num，只一行
}
int main()
{
    pthread_t thread1;
    pthread_t thread2;
    pthread_create(&thread1, NULL, ThreadFunc, NULL);
    pthread_create(&thread2, NULL, ThreadFunc, NULL);
 
    void *status;
    pthread_join(thread1, &status);
    pthread_join(thread2, &status);
    printf("num=%d\r\n", num);
    return 0;
}
```
其中线程函数`ThreadFunc()`的汇编代码如下：
```
(gdb) disassemble ThreadFunc
Dump of assembler code for function ThreadFunc:
   0x00000000004005f6 <+0>:     push   %rbp
   0x00000000004005f7 <+1>:     mov    %rsp,%rbp
   0x00000000004005fa <+4>:     mov    %rdi,-0x8(%rbp)
   0x00000000004005fe <+8>:     mov    0x2004a0(%rip),%eax        # 0x600aa4 <num>
   0x0000000000400604 <+14>:    add    $0x1,%eax
   0x0000000000400607 <+17>:    mov    %eax,0x200497(%rip)        # 0x600aa4 <num>
   0x000000000040060d <+23>:    nop
   0x000000000040060e <+24>:    pop    %rbp
   0x000000000040060f <+25>:    retq
End of assembler dump.
```
我们关注一下线程函数`ThreadFunc()`，在C语言代码里，它只做了一件事，就是把全局变量num+1；而对应的汇编代码里，我们可以看到，机器需要3条指令来完成这个操作，即：

1. 从内存中读入至寄存器（第6行）；
2. 在寄存器中对变量做修改操作（第7行）；
3. 把新的值写回到内存中（第8行）。

在本例中，`main()`函数启动了2个线程，同时对全局变量`num`做自增操作，假如2个线程以如下的方式执行：

1. 线程1将num的值从内存读入至寄存器中，%eax=0；
2. 线程2将num的值从内存读入至寄存器中，%eax=0；
3. 线程1对寄存器中的值做自增操作，%eax=1；
4. 线程2对寄存器中的值做自增操作，%eax=1；
5. 线程1将寄存器中的值写回到内存里，此时num的值为1；
6. 线程2将寄存器中的值写回到内存里，此时num的值仍为1；

问题就出在第5和第6步：第5步时，线程1已经将num的值修改为了1，但是这个修改对线程2来说**不可见**，此时num的值就出现了**不一致**的情况，那么当第6步线程2将num的值再修改的时候，就覆盖了线程1的修改。最后num的值预期是2，但是结果可能是2，也可能是1，也就是刚刚描述的这种场景。

除了计算机体系结构的原因之外，程序使用变量的方式也会带来**竞争**的问题。比如一个线程把某个共享变量+1，然后其他线程会根据这个值做出某个决定，但是很有可能当那个线程还没有把变量的值写进去的时候，其他线程就过来读取了，这时候就会读取到一个不一致的值，从而影响程序的行为。

为了解决这种线程同步的问题，Pthreads提供了以下几种机制：

- **互斥量** - [《基于线程的并发编程——互斥量》][2]（待补充）
- **读写锁** - [《基于线程的并发编程——读写锁》][3]（待补充）
- **条件变量** - [《基于线程的并发编程——条件变量》][4]（待补充）
- **自旋锁** - [《基于线程的并发编程——自旋锁》][5]（待补充）
- **屏障** - [《基于线程的并发编程——屏障》][6]（待补充）

# 3. 实例

## 3.1. 生产者-消费者

## 3.2. 读者-写者

# 4. 参考资料

1. [POSIX Threads Programming][20]
2. 《Advanced Programming in the UNIX Environment》
3. 《Computer Systems:A Programmer's Perspective》
4. [Linux man pages online][21]

[1]: http://stillwaters.top
[2]: http://stillwaters.top
[3]: http://stillwaters.top
[4]: http://stillwaters.top
[5]: http://stillwaters.top
[6]: http://stillwaters.top
[20]: https://computing.llnl.gov/tutorials/pthreads/
[21]: http://man7.org/linux/man-pages/index.html